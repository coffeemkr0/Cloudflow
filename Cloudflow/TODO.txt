Figure out a way to save a job configuration to a database and reload it. 
Serializing the entire job configuration into one json string is probably not going to work since it will
not have the Types for the triggers and steps when it tries to deserialize them. It is using the abstract types.

See if this method might cleanup the code for an extension - https://stackoverflow.com/questions/4237532/mef-metadata-from-the-exported-parts
Marking up the constructors for jobs, triggers or steps is inconvenient - I forgot to do it and did not realize why no extensions were loading.
Need to at least throw a custom exception when no extension is found - could possibly switch to [Import] instead of [ImportMany] or
find the attribute value that specifies at least one must be found.

Create a default job and job configuration extension that has no triggers or steps, just initialized containers for them. This is what a user would typically use
to setup a job if they are not trying to extend the job itself.
Create a FolderWatch trigger
Create a MoveFile step
Using the default job, create a job that watches a folder and copys files that are placed in it to another folder
Save the job to the database
load the job from the database
Push the job to the agent
start the agent and run the job
test the job by placing files into the watch folder

Create, save and then load the TestJob, its triggers and steps from the database. After that, start using what is loaded from the database only.

Might be able to use an attribute to specify the configuration type for a job and not have to specify the JobExtensionId so many times.

It's taking a few extra seconds the first time a RunController is created - probably from instantiating a DbContext for the first time and initializing the
connection pool.

Make sure the CreateNewConfiguration methods actually create a new configuration instance
Replace hardcoded paths to the extension assembly.

Look at not creating a run controller every time a trigger is fired. A dedicated thread for working on runs in a queue might be better. 
This could still allow jobs to trigger multiple runs asynchronously but would give the ability to limit the numer of runs in progress.
Make sure that controllers are not re-created but Jobs, Triggers and Steps can be?

Select a run in progress and view the console output
Select a completed run and view the log - should look like console output just for that run - this may involve passing the run logger around so that steps can use it
Add the ability for runs to be queued instead of starting immediately
Add the ability to cancel a run

Cleanup namespaces and class names in projects to make them more clear what they are for.


Change the Run Id in the agent Run model to a Guid that matches the Id that gets generated when a run is created
Update the existing run record when a run ends (complete or fail)

Create a view of what the agent is actually doing to expand on the Running status.

Add the ability to download an agent - the setup program actually has to be ran first
	before you can add an agent to the web app so that you can know what port to enter
Add the ability to test the connection to an agent while adding it to the web app
	Perhaps use the Start Listening button on the Setup program to make this work
Allow jobs, triggers and steps to perform impersonation
	Check out the Options on Tfs builds - Allow Scripts to Access OAuth Token

Sign everything so that it is trusted
Make it so that runs have a configurable name format that is generated when the run starts (similar to Tfs builds)

Use a ViewModel for agent configurations instead of using the model directly from the Core assembly

Triggers starting other triggers:
	For example, a trigger that watches for folders being created in a watch folder
	This trigger being fired Starts another trigger that watches for files that are created in the new folder
	This file watcher trigger getting fired starts a run
	This sounds like having dynamically created triggers

Trigger examples:
	Watch folder
	Monitor an email account
	A WCF or SignalR service that listens for Http requests
	Poll a database
	Fire an event from Sql Server that fires the trigger (not polling)

Add an option to steps for continuing after errors
Keep a history of runs and their logs and status etc.
start making methods extensible
Enable the agent to run as a windows server
Authenitcaiton - create a user account and only access "my stuff"




Ability to setup "jobs" - Jobs being the settings that are required for the agent to know what to do:
	1. Input folder that contains the jpegs
	2. Output folder to place the pdfs



